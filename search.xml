<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo链接SEO优化]]></title>
    <url>%2F20190731%2Fhexo-link-seo-optimization.html</url>
    <content type="text"><![CDATA[序言hexo 生成文章的默认链接是“https://blog.simcom.ltd/2019/01/14/“Markdown file name””,如果文章标题是英文的还好，如果是中文的，看着就各种别扭，而且这样也不利于seo优化。以下内容是讲如何做链接的seo优化. 优化方法 添加urlname属性(手动) hexo插件法(hexo插件官网) hexo-translate-title: Translate the chinese title of Hexo blog to english words automatially hexo-permalink-pinyin: A Hexo plugin which convert Chinese title to transliterate permalink. hexo-abbrlink: Auto create one and only link for every post for hexo hexo-number-title: The hexo blog post url is displayed as a number. 添加urlname属性在md文件的Front-matter区域新增urlname属性，可以是文章的英文Title也可以是其它自定义标识，所以每次编写Markdown你都得这么做，参考如下 --- title: hexo链接SEO优化 urlname: Hexo link SEO optimization date: 2019-1-14 categories: hexo author: mendax tags: hexo cover_picture: http://xxx.xx/xxx.jpg top: 1 --- 利用hexo插件大概看了下，这些插件其实主要还是两个方法的是实现地址的唯一性 生成唯一的值当作链接的地址 通过翻译的方式生成英文的地址 我这里选择的是hexo-translate-title 安装npm install hexo-translate-title --save 配置修改hexo根项目下的_config.yml translate_title: translate_way: google # google,youdao,baidu_with_appid,baidu_no_appid is_need_proxy: false # true | false # proxy_url: http://localhost:50018 # Your proxy_url # youdao_api_key: '' # Your youdao_api_key # youdao_keyfrom: xxxx-blog # Your youdao_keyfrom # baidu_appid: '' # Your baidu_appid # baidu_appkey: '' # Your baidu_appkey #修改原链接格式：permalink: :year/:month/:day/:title/ permalink: :year:month:day/:translate_title.html 发布hexo clean hexo g gulp // 执行压缩，两条命令可以合并：hexo g && gulp hexo d //执行部署命令]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gulp4对Hexo博客压缩]]></title>
    <url>%2F20190731%2Fcompress-hexo-blog-with-gulp4.html</url>
    <content type="text"><![CDATA[安装插件在博客的根目录执行以下命令 npm install gulp --save 安装功能模块介绍(我压缩图片用不上，我的图片全部上传github) gulp-htmlclean // 清理html gulp-htmlmin // 压缩html gulp-minify-css // 压缩css gulp-uglify // 混淆js gulp-imagemin // 压缩图片npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save gulp配置在根目录下创建gulpfile.js文件var gulp = require('gulp'); //Plugins模块获取 var minifycss = require('gulp-minify-css'); var uglify = require('gulp-uglify'); var htmlmin = require('gulp-htmlmin'); var htmlclean = require('gulp-htmlclean'); //压缩css gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public')); }); //压缩html gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public')) }); //压缩js 不压缩min.js gulp.task('minify-js', function () { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']) .pipe(uglify()) .pipe(gulp.dest('./public')); }); //4.0以前的写法 //gulp.task('default', [ // 'minify-html', 'minify-css', 'minify-js' //]); //4.0以后的写法 // 执行 gulp 命令时执行的任务 gulp.task('build', gulp.parallel('minify-html', 'minify-css', 'minify-js', function() { // Do something after a, b, and c are finished. })); 执行压缩hexo clean hexo g gulp // 执行压缩，两条命令可以合并：hexo g && gulp hexo d //执行部署命令]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo增加搜索功能]]></title>
    <url>%2F20190731%2Fhexo-increases-search-function.html</url>
    <content type="text"><![CDATA[安装插件在博客的根目录执行以下命令 npm install hexo-generator-searchdb --save 全局配置文件_config.ymlsearch: path: search.xml field: post format: html limit: 10000 hexo主题配置文件# Local search # Dependencies: https://github.com/flashlab/hexo-generator-search local_search: enable: true]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用Hexo脚本——备份博客源文件]]></title>
    <url>%2F20190731%2Fuse-hexo-scripts-backup-blog-source-files.html</url>
    <content type="text"><![CDATA[Hexo脚本 Hexo命令会自动触发一些事件，利用这些事件，我们可以为不同的Hexo命令添加一些额外的自定义功能。我们只需要在Hexo根目录下添加一个scripts文件夹，然后将我们编写的脚本文件放在这个文件夹中，当某一事件被触发时，接收相应事件的脚本就会被自动执行。 自动备份博客源文件 Hexo部署的github-pages博客在发布时只会上传生成的页面文件，而我们的源文件却没有上传,这就导致博客源文件没有备份，当然我们可以在GitHub上新建一个repo来管理我们的源文件，但是这样每次都需要手动备份，有点麻烦。这个时候，就需要利用Hexo事件来运行自动脚本了。直接上代码： // filename: backup.js require('shelljs/global'); try { hexo.on('generateAfter', function() {//当generate完成后执行备份 run(); }); } catch (e) { console.log("产生了一个错误 !，错误详情为：" + e.toString()); } function run() { echo("==================Source Auto Backup Begin========================"); cd('/home/dhmemi/Documents/blog_dhmemi'); //此处修改为Hexo根目录路径 exec('if [ ! -d "public" ]; then\nmkdir public\nfi'); if (exec('cp -avx source public/').code !== 0) { echo('Error: copy source failed'); exit(1); } else { echo("==============Source Auto Backup Complete=========================") } } 这个脚本所完成的功能很简单，就是在Hexo生成（generate）完成后，将source文件夹复制到public目录下，这样，在发布（deploy）时，源文件目录就会自动被复制到.git_deploy目录下并被当作生成目录发布到github上。保存上面的脚本到scripts目录下即可。当然在运行这个脚本之前，你一定注意到了第一行的”shelljs/global”，所以你要安装shelljs模块： sudo npm install --save shelljs]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动过程中获取组件宽高的五种方式]]></title>
    <url>%2F20190730%2Ffive-ways-to-get-the-width-and-height-of-components-during-startup-process.html</url>
    <content type="text"><![CDATA[问题：在Activity的启动流程中通过getWidht和getHeight方法获取组件的宽度和高度//在onCreate方法中调用，用于获取TextView的宽度和高度 private void getTextHeightAndWidth() { // 我们定义的用于获取宽度和高度的组件 titleText = (TextView) findViewById(R.id.text_title); int height = titleText.getHeight(); int width = titleText.getWidth(); Log.i(TAG, "height:" + height + " " + "width:" + width); } 打印结果I/MainActivity: height:0 width:0 咦？为什么打印的height和width都是0呢？我们在执行一遍呢？结果还是一样的，两个变量都是0，难道这段代码不能再onCreate方法中调用，那么我们试试在onResume方法中调用呢？ 只能说然并卵，打印的结果依然是： I/MainActivity: height:0 width:0 好吧，问题已经出来了，看样子我们是不能再onCreate方法或者是onResume方法中调用该方法获取组件的宽高的，但是这是为什么呢？平时我们都是通过这个方法来获取组件的宽高的，并且也没问题啊，比如我们将这个方法的调用逻辑写在按钮的点击事件之内呢？我们再来试试。 //这里的button1是我们定义的Button组件，并且我们重写了Button的点击事件，在其中调用了获取组件宽高的方法 button1 = (Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getTextHeightAndWidth(); } }); 这样敲完代码之后，我们执行这段代码，界面入下图所示： 打印结果I/MainActivity: height:57 width:225 恩？这时候我们发现其打印出了组件的宽和高，那么为什么我们在Activity的onCreate、onResume方法中打印的时候，输出的组件宽高都是为0呢？ 原因 Activity的启动流程和Activity的布局文件加载绘制流程，其实没有相关的关系的，其实两个异步的加载流程，这样我们在Activity的onCreate和onResume方法调用textView.getHeight或者是textView.getWidth方法的时候，其组件并没有执行完绘制流程，因此此时获取到的组件的宽高都是默认的0，也就是无法获取组件的宽和高。但是当我们将获取组件宽高的方法卸载按钮的点击事件的时候，由于此时按钮已经显示出来了，所以证明布局文件已经加载绘制完成，这时候点击组件执行组件的获取宽高方法，就能正常的获取到组件的宽和高了。这也就是为什么我们在onCreate和onResume方法中调用获取组件宽高都是0，而在按钮的点击事件中获取的时候正常的原因了 解决方案重写Activity的onWindowFocusChanged方法//重写Acitivty的onWindowFocusChanged方法 @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); /** * 当hasFocus为true的时候，说明Activity的Window对象已经获取焦点，进而Activity界面已经加载绘制完成 */ if (hasFocus) { int widht = titleText.getWidth(); int height = titleText.getHeight(); Log.i(TAG, "onWindowFocusChanged width:" + widht + " " + " height:" + height; } } 说明：这样重写onWindowFocusChanged方法，当获取焦点的时候我们就可以通过getWidth和getHeight方法得到组件的宽和高了。但是这时候这个方法的逻辑可能会执行多次，也就是说只要我们的Activity的window对象获取了焦点就会执行该语句，所以我们需要做一些逻辑判断，让它在我们需要打印获取组件宽高的时候在执行。 为组件添加OnGlobalLayoutListener事件监听/** * 为Activity的布局文件添加OnGlobalLayoutListener事件监听，当回调到onGlobalLayout方法的时候我们通过getMeasureHeight和getMeasuredWidth方法可以获取到组件的宽和高 */ private void initOnLayoutListener() { final ViewTreeObserver viewTreeObserver = this.getWindow().getDecorView().getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { Log.i(TAG, "开始执行onGlobalLayout()........."); int height = titleText.getMeasuredHeight(); int width = titleText.getMeasuredWidth(); Log.i(TAG, "height:" + height + " width:" + width); // 移除GlobalLayoutListener监听 MainActivity.this.getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(this); } }); } 说明需要说明的是这里的onGlobalLayout方法会在Activity的组件执行完onLayout方法之后执行，这里的onLayout方法主要用于计算组件的宽高操作，具体可参考：Android源码解析（十八）–&gt;Activity布局绘制流程，这样当我们计算完组件的宽高之后再执行获取组件的宽高操作，自然能够获取到组件的宽度和高度。 为组件添加OnPreDrawListener事件监听/** * 初始化viewTreeObserver事件监听,重写OnPreDrawListener获取组件高度 */ private void initOnPreDrawListener() { final ViewTreeObserver viewTreeObserver = this.getWindow().getDecorView().getViewTreeObserver(); viewTreeObserver.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { Log.i(TAG, "开始执行onPreDraw()........."); int height = titleText.getMeasuredHeight(); int width = titleText.getMeasuredWidth(); Log.i(TAG, "height:" + height + " width:" + width); // 移除OnPreDrawListener事件监听 MainActivity.this.getWindow().getDecorView().getViewTreeObserver().removeOnPreDrawListener(this); return true; } }); } 说明需要说明的是这里的onPreDraw方法会在Activity的组件执行onDraw方法之前执行，熟悉我们Activity组件加载绘制流程的同学应该知道，这里的onDraw方法主要用于执行真正的绘制组件操作，而这时候我们已经计算出来了组件的位置，宽高等操作，这样之后再执行获取组件的宽高操作，自然能够获取到组件的宽度和高度。 使用View.post方法获取组件的宽高/** * 使用View的post方法获取组件的宽度和高度 */ private void initViewHandler() { titleText.post(new Runnable() { @Override public void run() { int width = titleText.getWidth(); int height = titleText.getHeight(); Log.i(TAG, "initViewHandler height:" + height + " width:" + width); } }); } 说明这里的view的post方法底层使用的是Android的异步消息机制，消息的执行在MainActivity主进程Loop执行之后，所以这时候也可以获取组件的宽高 通过Handler对象使用异步消息获取组件的宽高/** * 在onCreate方法中发送异步消息，在handleMessage中获取组件的宽高 */ private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { int width = titleText.getWidth(); int height = titleText.getHeight(); Log.i(TAG, "initViewHandler height:" + height + " width:" + width); } } }; 说明和上面使用view.post方法类似，这里用的是异步消息获取组件的宽高，而这里的异步消息的执行过程是在主进程的主线程的Activity绘制流程之后，所以这时候可以获取组件的宽高]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的搭建]]></title>
    <url>%2F20190726%2Fhexo-blog-building.html</url>
    <content type="text"><![CDATA[准备工作(window7 64位) 下载node.js并安装（node官网下载安装），默认会安装npm 下载安装git（git官网下载安装） 下载安装hexo(hexo官方文档) 安装Node控制台打印出对应Node版本就说明安装成功了 node -v 安装git 校验是否安装成功 git version 安装hexo 下载 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 全局安装 npm install -g hexo #-g 全局安装hexo 校验是否安装成功 hexo -v 生成hexo模板进入相对应的目录（我这边是D磁盘下） hexo init blog #blog 我这边是直接在D盘下 创建个blog 文件夹 cd blog npm install hexo server #运行程序，访问本地localhost:4000可以看到博客已经搭建成功 将博客与Github关联 在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名(一个账号只能创建一个githubpage，且后缀必须“.github.io”) 打开本地的Blog文件夹项目内的_config.yml配置文件，将其中的type设置为git，其中repository 可为SSH地址(我这是SSH地址) deploy: type: git repository: git@github.com:mendax92/mendax92.github.io.git branch: master 或者 deploy: type: git repository: https://github.com/mendax92/mendax92.github.io.git branch: master 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题) cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。``` ssh-keygen -t rsa -C "邮件地址" #找到.ssh\id_rsa.pub文件，打开并复制里面的内容，->github主页，->个人设置 -> SSH and GPG keys -> New SSH key ssh -T git@github.com #测试是否成功 git config --global user.name "liuxianan"// 你的github用户名，非昵称 git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 安装hexo-deployer-git插件包并发布 npm install hexo-deployer-git –save hexo g #（本地生成静态文件） hexo d #（将本地静态文件推送至Github） 更新文章定位到我们的hexo根目录，执行命令 Hexo官网指令大全 hexo new 'my-first-blog' #hexo会帮我们在_posts下生成相关md文件|也可以手动在_posts创建文件 hexo clean #清除缓存文件 hexo g #生成静态页面至public目录 hexo s #启动服务器 hexo d #部署网站 添加页面hexo new page "categories" #添加分类页面 hexo new page “tags” #添加标签页面 hexo new page "about #添加关于页面]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnsupportedOperationException错误分析]]></title>
    <url>%2F20190726%2Funsupportedoperationexception-error-analysis.html</url>
    <content type="text"><![CDATA[1. 错误分析 java.lang.UnsupportedOperationException 大致的意思是，你调用的关于的容器的操作是不被允许的。 2. 个人理解 这不是说没有该方法，如果没有该方法的话，在编译期间就可以识别。 有该方法，也就是说该方法受到了限制。 限制就类似于权限限制之类的东西。（类似于linux 中对于文件权限的管理）。如果list不能实现这种权限的限制，那么会存在一些安全性的问题。所以可以看出来，权限在大部分场合都是一个必备的成分。 不同的粒度上，相关的语言提供了不同控制权限的方式。 本质上，下面的错误案例，都可以归结为权限问题。 3. 举例Collections.unmodifiableList（*）引起的错误Collections.unmodifiableList 起到了对list**设置权限的目的**。 private static void testReadOnly(){ //1.创建一个list。并且这个list的访问权限未进行设置。 List modifyList = new ArrayList(); //2.向其中插入相关的数据。【可行】 modifyList.add("you"); modifyList.add("are"); modifyList.add("boy"); //3.对list进行设置。使之可读。 modifyList = Collections.unmodifiableList(modifyList); //4.在次插入，出现错误。 modifyList.add("hello"); } 解决办法 该只读的权限维护的是，修改list中引用的权限。 但是如果你如果不改引用，是可以通过引用来更改其所指向的对象的。 private static void testChangeReadOnly(){ ////1.创建2个list。并且这2个list的访问权限未进行设置。 List modifyList = new ArrayList(); List normalList= new LinkedList(); //2.向modifylist中插入元素。 modifyList.add(new StringBuilder("you")); modifyList.add(new StringBuilder("are")); modifyList.add(new StringBuilder("boy")); //3.设置可读权限 modifyList = Collections.unmodifiableList(modifyList); //4.将只读的modifyList中的引用复制到normalList中。 normalList.addAll(modifyList); //5.向normalList中插入数据。 normalList.add(new StringBuilder("hello")); System.out.println(normalList.toString());//[you, are, boy, hello] //6.更改只读list中，引用所指向的对象的值。 System.out.println("更改之前 ----> " + modifyList.toString());//更改之前 ----> [you, are, boy] //更改 modifyList.get(1).append("~~~~~"); System.out.println("更改之后 ----> " + modifyList.toString());//更改之后 ----> [you, are~~~~~, boy] } 输出结果： [you, are, boy, hello]更改之前 —-&gt; [you, are, boy]更改之后 —-&gt; [you, are~, boy] 使用Arrays.asLisvt()后调用add，remove这些method时出现 Arrays.asLisvt() 返回java.util.ArraysArrayList，而不是ArrayList。 ArraysArrayList和ArrayList都是继承AbstractList，remove，add等method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。 ArrayList override这些method来对list进行操作，但是Arrays$ArrayList没有override remove(int)，add(int)等，所以throw UnsupportedOperationException 解决办法和上面异常的处理一样，将引用操作转移到其他地方。 List list = Arrays.asList(fixArray[]); List newList = new ArrayList(list);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>错误分析</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断当前activity 是否在栈顶]]></title>
    <url>%2F20190726%2Fdetermine-if-the-current-activity-is-at-top-of-stack.html</url>
    <content type="text"><![CDATA[判断当前activity 是否在栈顶的两种方法 通过代码private static final String ACTIVITY_NAME_PARENTMEETING = "com.sunnyberry.xst.activity.parentmeeting.ParentMeetingActivity"; Utils.activityIsBackground(mContext, ACTIVITY_NAME_PARENTMEETING); /** * 判断activity是否是在栈顶 */ public static boolean activityIsBackground(Context context, String clazzName) { ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); RunningTaskInfo info = manager.getRunningTasks(1).get(0); String shortClassName = info.topActivity.getShortClassName(); //类名 String className = info.topActivity.getClassName(); //完整类名 String packageName = info.topActivity.getPackageName(); //包名 if (TextUtils.isEmpty(clazzName)) { return false; } return (clazzName.equals(className)); } 通过adb命令行获取当前的activityadb shell dumpsys activity | findstr “mFocusedActivity”]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
