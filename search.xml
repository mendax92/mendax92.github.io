<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android和H5交互打开摄像头并上传图片]]></title>
    <url>%2F20190816%2Fandroid-and-h5-interactively-open-the-camera-upload-pictures.html</url>
    <content type="text"><![CDATA[前言最近一个需求是，原生APP打开H5页面，然后打开摄像头并且上传图片，通过浏览器查看到H5那边的按钮标签是“&lt;input type=”file” id=”fileselect” accept=”image/*” name=”fileselect” capture=”camera” style=”width: 1440px; height: 272px; top: 0px;”&gt;”以下是解决方案 思路流程 打开webview对js的支持(mWebView.getSettings().setJavaScriptEnabled(true)) WebView.setWebChromeClient监听(setWebChromeClient监听:辅助WebView处理JavaScript的对话框，网站图标，网站title，加载进度等) 获取相机权限并打开相机 获取拍摄成功的回调并上传文件 详细流程初始化webviewprivate void initWebView() { mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setDomStorageEnabled(true); mWebView.setWebViewClient(new WebViewClient() { @Override public void onPageFinished(WebView view, String url) { super.onPageFinished(view, url); tvClose.setVisibility(mWebView.canGoBack() ? View.VISIBLE : View.GONE); } @Override public void onPageStarted(WebView view, String url, Bitmap favicon) { super.onPageStarted(view, url, favicon); } }); mWebView.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { super.onProgressChanged(view, newProgress); mProgressBar.setProgress(newProgress); if (newProgress == 100) { mProgressBar.setVisibility(View.GONE); } } //For Android >= 5.0 @Override public boolean onShowFileChooser(WebView webView, ValueCallback filePathCallback, FileChooserParams fileChooserParams) { uploadMessageAboveL = filePathCallback; uploadPicture(); return true; } //For Android >= 4.1 public void openFileChooser(ValueCallback valueCallback, String acceptType, String capture) { uploadMessage = valueCallback; uploadPicture(); } }); String onlineUrl = "https://xxx.com"; mWebView.loadUrl(onlineUrl); } 打开摄像头/** * 拍照 */ private void takePhoto() { StringBuilder fileName = new StringBuilder(); Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); fileName.append(UUID.randomUUID()).append("_upload.png"); File tempFile = new File(mContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES), fileName.toString()); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri uri = FileProvider.getUriForFile(mContext, BuildConfig.APPLICATION_ID + ".fileProvider", tempFile); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); } else { Uri uri = Uri.fromFile(tempFile); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); } mCurrentPhotoPath = tempFile.getAbsolutePath(); startActivityForResult(intent, REQUEST_CODE_CAMERA); } 获取拍摄成功的回调并上传文件@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_ALBUM || requestCode == REQUEST_CODE_CAMERA) { if (uploadMessage == null && uploadMessageAboveL == null) { return; } //取消拍照或者图片选择时 if (resultCode != RESULT_OK) { //一定要返回null,否则&lt;input file &gt;就是没有反应 if (uploadMessage != null) { uploadMessage.onReceiveValue(null); uploadMessage = null; } if (uploadMessageAboveL != null) { uploadMessageAboveL.onReceiveValue(null); uploadMessageAboveL = null; } } //拍照成功和选取照片时 if (resultCode == RESULT_OK) { Uri imageUri = null; switch (requestCode) { case REQUEST_CODE_ALBUM: if (data != null) { imageUri = data.getData(); } break; case REQUEST_CODE_CAMERA: if (!TextUtils.isEmpty(mCurrentPhotoPath)) { File file = new File(mCurrentPhotoPath); Uri localUri = Uri.fromFile(file); Intent localIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, localUri); sendBroadcast(localIntent); imageUri = Uri.fromFile(file); mLastPhothPath = mCurrentPhotoPath; } break; } //上传文件 if (uploadMessage != null) { uploadMessage.onReceiveValue(imageUri); uploadMessage = null; } if (uploadMessageAboveL != null) { uploadMessageAboveL.onReceiveValue(new Uri[]{imageUri}); uploadMessageAboveL = null; } } } } 完整代码/** * webview通用加载类 * 加载进度条显示 * 上传图片的支持 */ public class WebActivity extends AppCompatActivity implements View.OnClickListener { Context mContext; private static final int REQUEST_CODE_ALBUM = 0x01; private static final int REQUEST_CODE_CAMERA = 0x02; private static final int REQUEST_CODE_PERMISSION_CAMERA = 0x03; WebView mWebView; ProgressBar mProgressBar; TextView tvClose; private ValueCallback uploadMessage; private ValueCallback uploadMessageAboveL; private String mCurrentPhotoPath; private String mLastPhothPath; private Thread mThread; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_web); mContext = this; //绑定控件ID initView(); //进度条初始化 initProgressBar(); //webview初始化 initWebView(); } @Override protected void onDestroy() { super.onDestroy(); mThread = null; mHandler = null; } private void initView() { mProgressBar = (ProgressBar) findViewById(R.id.progressBar); mWebView = (WebView) findViewById(R.id.webview); tvClose = (TextView) findViewById(R.id.tv_close); TextView tvBack = (TextView) findViewById(R.id.tv_back); tvClose.setOnClickListener(this); tvBack.setOnClickListener(this); } private void initProgressBar() { mProgressBar.setMax(100); } private void initWebView() { mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setDomStorageEnabled(true); mWebView.setWebViewClient(new WebViewClient() { @Override public void onPageFinished(WebView view, String url) { super.onPageFinished(view, url); tvClose.setVisibility(mWebView.canGoBack() ? View.VISIBLE : View.GONE); } @Override public void onPageStarted(WebView view, String url, Bitmap favicon) { super.onPageStarted(view, url, favicon); } }); mWebView.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { super.onProgressChanged(view, newProgress); mProgressBar.setProgress(newProgress); if (newProgress == 100) { mProgressBar.setVisibility(View.GONE); } } //For Android >= 5.0 @Override public boolean onShowFileChooser(WebView webView, ValueCallback filePathCallback, FileChooserParams fileChooserParams) { uploadMessageAboveL = filePathCallback; uploadPicture(); return true; } //For Android >= 4.1 public void openFileChooser(ValueCallback valueCallback, String acceptType, String capture) { uploadMessage = valueCallback; uploadPicture(); } }); String onlineUrl = "https://xxx.com"; mWebView.loadUrl(onlineUrl); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.tv_back: onBackPressed(); break; case R.id.tv_close: finish(); break; } } @Override public void onBackPressed() { if (mWebView != null && mWebView.canGoBack()) { mWebView.goBack(); } else { finish(); } } Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); takePhoto(); } }; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (grantResults == null && grantResults.length == 0) { return; } if (requestCode == REQUEST_CODE_PERMISSION_CAMERA) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { takePhoto(); } else { // Permission Denied new AlertDialog.Builder(mContext) .setTitle("无法拍照") .setMessage("您未授予拍照权限") .setNegativeButton("取消", null) .setPositiveButton("去设置", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); localIntent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); localIntent.setData(Uri.fromParts("package", getPackageName(), null)); startActivity(localIntent); } }).create().show(); } } } /** * 选择相机或者相册 */ public void uploadPicture() { AlertDialog.Builder builder = new AlertDialog.Builder(WebActivity.this); builder.setTitle("请选择图片上传方式"); //取消对话框 builder.setOnCancelListener(new DialogInterface.OnCancelListener() { @Override public void onCancel(DialogInterface dialog) { //一定要返回null,否则&lt;input file &gt;就是没有反应 if (uploadMessage != null) { uploadMessage.onReceiveValue(null); uploadMessage = null; } if (uploadMessageAboveL != null) { uploadMessageAboveL.onReceiveValue(null); uploadMessageAboveL = null; } } }); builder.setPositiveButton("相机", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { if(!TextUtils.isEmpty(mLastPhothPath)){ //上一张拍照的图片删除 mThread = new Thread(new Runnable() { @Override public void run() { File file = new File(mLastPhothPath); if(file!= null){ file.delete(); } mHandler.sendEmptyMessage(1); } }); mThread.start(); }else{ //请求拍照权限 if (ActivityCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { takePhoto(); } else { ActivityCompat.requestPermissions(WebActivity.this, new String[]{Manifest.permission.CAMERA}, REQUEST_CODE_PERMISSION_CAMERA); } } } }); builder.setNegativeButton("相册", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { chooseAlbumPic(); } }); builder.create().show(); } /** * 拍照 */ private void takePhoto() { StringBuilder fileName = new StringBuilder(); Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); fileName.append(UUID.randomUUID()).append("_upload.png"); File tempFile = new File(mContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES), fileName.toString()); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri uri = FileProvider.getUriForFile(mContext, BuildConfig.APPLICATION_ID + ".fileProvider", tempFile); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); } else { Uri uri = Uri.fromFile(tempFile); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); } mCurrentPhotoPath = tempFile.getAbsolutePath(); startActivityForResult(intent, REQUEST_CODE_CAMERA); } /** * 选择相册照片 */ private void chooseAlbumPic() { Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); i.setType("image/*"); startActivityForResult(Intent.createChooser(i, "Image Chooser"), REQUEST_CODE_ALBUM); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_ALBUM || requestCode == REQUEST_CODE_CAMERA) { if (uploadMessage == null && uploadMessageAboveL == null) { return; } //取消拍照或者图片选择时 if (resultCode != RESULT_OK) { //一定要返回null,否则&lt;input file &gt;就是没有反应 if (uploadMessage != null) { uploadMessage.onReceiveValue(null); uploadMessage = null; } if (uploadMessageAboveL != null) { uploadMessageAboveL.onReceiveValue(null); uploadMessageAboveL = null; } } //拍照成功和选取照片时 if (resultCode == RESULT_OK) { Uri imageUri = null; switch (requestCode) { case REQUEST_CODE_ALBUM: if (data != null) { imageUri = data.getData(); } break; case REQUEST_CODE_CAMERA: if (!TextUtils.isEmpty(mCurrentPhotoPath)) { File file = new File(mCurrentPhotoPath); Uri localUri = Uri.fromFile(file); Intent localIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, localUri); sendBroadcast(localIntent); imageUri = Uri.fromFile(file); mLastPhothPath = mCurrentPhotoPath; } break; } //上传文件 if (uploadMessage != null) { uploadMessage.onReceiveValue(imageUri); uploadMessage = null; } if (uploadMessageAboveL != null) { uploadMessageAboveL.onReceiveValue(new Uri[]{imageUri}); uploadMessageAboveL = null; } } } } }]]></content>
      <tags>
        <tag>Android</tag>
        <tag>H5交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android解决8.0通知栏不显示问题]]></title>
    <url>%2F20190816%2Fandroid-solves-80-notification-bar-does-not-display-the-problem.html</url>
    <content type="text"><![CDATA[前言开会时领导说更新按钮点击没有反应，后面根据log日志“NotificationService: No Channel found for pkg=xxx.xxx.xxx”查到原因是因为 按钮点击之后本应在通知栏下载的通知没有显示，android 8.0加入了通知渠道，感觉加入通知渠道这个东西之后体验确实好些，打比方APP 中有多种推送通知，-打折通知，-APP更新通知，-IM聊天通知.我可以在设置中对APP 进行通知管理，打比方只允许IM聊天的通知。下面是通知渠道加入的教程 通知渠道创建流程 notification的创建流程NotificationChannel的官方讲解 通知渠道NotificationChannel的三个参数 channelId：通知渠道的ID 可以是任意的字符串，全局唯一就可以 channelName：通知渠道的名称，这个是用户可见的，开发者需要认真规划的命名 importance：通知渠道的重要等级，有一下几个等级，不过这个用户都是可以手动修改的 通知渠道创建(如果通知类型比较少的话，可以省略渠道组的创建和设置组ID的流程)private final String GROUP_ID = "my_group_01"; private final int NOTIFICATION_ID = 1; private final String CHANNEL_NAME = "APP更新"; private final String CHANNEL_DESC = "APP更新通知"; private final String CHANNEL_ID = "2"; //通知渠道组的创建 notificationManager.createNotificationChannelGroup(new NotificationChannelGroup(GROUP_ID, "GROUP_NAME")); NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH); //设置组ID channel.setGroup(GROUP_ID); channel.setShowBadge(true); channel.setLightColor(Color.RED); channel.enableLights(true); notificationManager.createNotificationChannel(channel); NotificationChannel channel2 = new NotificationChannel(CHANNEL_ID_2, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH); //设置组ID channel2.setGroup(GROUP_ID); channel2.setShowBadge(true); channel2.setLightColor(Color.RED); channel2.enableLights(true); notificationManager.createNotificationChannel(channel2); 管理通知渠道删除渠道notificationManager.deleteNotificationChannel(CHANNEL_ID); 删除渠道组notificationManager.deleteNotificationChannelGroup(GROUP_ID); 补充 加入通知渠道之后发现依然通知无法显示，而且一直都是“NotificationService: No Channel found for pkg=xxx.xxx.xxxstackoverflow,谷歌，百度找了个遍，有说以下三个是必须要设置的（然而我试了并没什么软用）builder.setContentTitle() // required.setSmallIcon() // required.setContentText() // required后我发现网上的教程都是”builder.setChannelId(CHANNEL_ID)”而我这边没有setChannelId()方法只有“setChannel()”,发觉有可能是V7包的问题将appcompat-v7包从“26.0.0-alpha1” 换成“26.0.1”就可以了.. 完整代码public class AppUpdateService extends Service { /**** * 发送广播的请求码 */ private final int REQUEST_CODE_BROADCAST = 0X0001; public static String packageName = "com.sunnyberry.xst.service.AppUpdateService"; /**** * 发送广播的action */ private final String BROADCAST_ACTION_CLICK = "servicetask"; /** * 通知 */ private Notification notification; /** * 通知的Id */ private final int NOTIFICATION_ID = 1; private final String CHANNEL_NAME = "APP更新"; private final String CHANNEL_DESC = "APP更新通知"; private final String CHANNEL_ID = "2"; /** * 通知管理器 */ private NotificationManager notificationManager; /** * 通知栏的远程View */ private RemoteViews mRemoteViews; /** * 下载请求. */ private DownloadRequest mDownloadRequest; /** * 通知栏操作的四种状态 */ public enum Status { DOWNLOADING, PAUSE, FAIL, SUCCESS } /** * 当前在状态 默认正在下载中 */ public static Status status = Status.DOWNLOADING; private MyBroadcastReceiver myBroadcastReceiver; protected static boolean isDownLoading = false; private String savePath; String url; @Override public void onCreate() { super.onCreate(); } @Nullable @Override public IBinder onBind(Intent intent) { return null; } public static void start(Context context, String url) { if (status == Status.SUCCESS || status == Status.FAIL) { stopService(context); } if (!Utils.isServiceRunning(context, packageName)) { Intent intent = new Intent(context, AppUpdateService.class); intent.putExtra("url", url); context.startService(intent); } } public static void stopService(Context activity) { Intent service = new Intent(activity, AppUpdateService.class); activity.stopService(service); } @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) { savePath = ConstData.CACHE_OTHER_PATH + getApplicationInfo().packageName + ".apk"; registerBroadCast(); url = intent.getStringExtra("url"); download(); return super.onStartCommand(intent, flags, startId); } /** * 注册按钮点击广播* */ private void registerBroadCast() { myBroadcastReceiver = new MyBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(BROADCAST_ACTION_CLICK); registerReceiver(myBroadcastReceiver, filter); } /** * 更新通知界面的按钮的广播 */ private class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (!intent.getAction().equals(BROADCAST_ACTION_CLICK)) { return; } switch (status) { case DOWNLOADING: /**当在下载中点击暂停按钮**/ pauseDownLoad(); mRemoteViews.setTextViewText(R.id.bt, "下载"); mRemoteViews.setTextViewText(R.id.tv_message, "暂停中..."); status = Status.PAUSE; notificationManager.notify(NOTIFICATION_ID, notification); break; case SUCCESS: /**当下载完成点击完成按钮时关闭通知栏**/ notificationManager.cancel(NOTIFICATION_ID); callInstallApk(); break; case FAIL: case PAUSE: /**当在暂停时点击下载按钮**/ download(); mRemoteViews.setTextViewText(R.id.bt, "暂停"); mRemoteViews.setTextViewText(R.id.tv_message, "下载中..."); status = Status.DOWNLOADING; notificationManager.notify(NOTIFICATION_ID, notification); break; } } } /** * 暂停下载 */ protected void pauseDownLoad() { if (mDownloadRequest != null && mDownloadRequest.isStarted() && !mDownloadRequest.isFinished()) { mDownloadRequest.cancel(); mDownloadRequest = null; isDownLoading = false; } } /** * 下载文件 */ protected void download() { if (TextUtils.isEmpty(url) || !url.startsWith("http")) { return; } showNotificationProgress(AppUpdateService.this); if (!isDownLoading) { isDownLoading = true; mDownloadRequest = DownloadHelper.download(url, ConstData.CACHE_OTHER_PATH, getApplicationInfo().packageName + ".apk", new DownloadHelper.Listener() { @Override public void onDownloadError(Exception exception) { isDownLoading = false; deleteApk(); downloadFail(); } @Override public void onProgress(int progress, long fileCount) { status = Status.DOWNLOADING; updateNotification(progress); } @Override public void onFinish(String filePath) { isDownLoading = false; downloadSuccess(); callInstallApk(); } @Override public void onCancel() { status = Status.FAIL; isDownLoading = false; } }); } } private void deleteApk() { File file = new File(savePath); if (file.exists()) file.delete(); } public void callInstallApk() { startActivity(getInstallIntent()); } public Intent getInstallIntent() { isDownLoading = false; try { String permission = "777"; String command = "chmod " + permission + " " + savePath; Runtime runtime = Runtime.getRuntime(); runtime.exec(command); } catch (IOException e) { e.printStackTrace(); } Intent intent = new Intent(); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(android.content.Intent.ACTION_VIEW); intent.setDataAndType(Uri.fromFile(new File(savePath)), "application/vnd.android.package-archive"); return intent; } /** * 显示一个下载带进度条的通知 * * @param context 上下文 */ public void showNotificationProgress(Context context) { /**获取通知管理器**/ notificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE); /**进度条通知构建**/ NotificationCompat.Builder builderProgress = new NotificationCompat.Builder(context); //构建渠道 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { //创建通知渠道 NotificationChannel mChannel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT); mChannel.setDescription(CHANNEL_DESC);//渠道描述 mChannel.enableLights(true);//是否显示通知指示灯 mChannel.enableVibration(false);//是否振动 mChannel.setLightColor(Color.GREEN);//小红点颜色 notificationManager.createNotificationChannel(mChannel);//创建通知渠道 //添加渠道 builderProgress.setChannelId(CHANNEL_ID); } /**设置为一个正在进行的通知**/ builderProgress.setOngoing(true); /**设置小图标**/ builderProgress.setSmallIcon(R.drawable.logo); /**新建通知自定义布局**/ mRemoteViews= getRemoteViews(context); /**设置自定义布局**/ builderProgress.setContent(mRemoteViews); /**设置滚动提示**/ builderProgress.setTicker("开始下载..."); notification = builderProgress.build(); /**设置不可手动清除**/ notification.flags = Notification.FLAG_NO_CLEAR; /**发送一个通知**/ notificationManager.notify(NOTIFICATION_ID, notification); } private RemoteViews getRemoteViews(Context context) { RemoteViews mRemoteViews = new RemoteViews(context.getPackageName(), R.layout.updata_notification); mRemoteViews.setTextViewText(R.id.tv_name, UIUtils.getString(R.string.app_name)); /**进度条ProgressBar**/ mRemoteViews.setProgressBar(R.id.pb, 100, 0, false); /**提示信息的TextView**/ mRemoteViews.setTextViewText(R.id.tv_message, "下载中..."); /**操作按钮的Button**/ mRemoteViews.setTextViewText(R.id.bt, "暂停"); /**设置左侧小图标*/ mRemoteViews.setImageViewResource(R.id.iv, R.drawable.logo); /**设置通过广播形式的PendingIntent**/ Intent intent = new Intent(BROADCAST_ACTION_CLICK); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, REQUEST_CODE_BROADCAST, intent, 0); mRemoteViews.setOnClickPendingIntent(R.id.bt, pendingIntent); return mRemoteViews; } /** * 下载更改进度 * * @param current 当前已下载大小 */ private void updateNotification(int current) { mRemoteViews.setTextViewText(R.id.tv_progress, current + "%"); mRemoteViews.setProgressBar(R.id.pb, 100, current, false); notificationManager.notify(NOTIFICATION_ID, notification); } /** * 下载失败 */ private void downloadFail() { status = Status.FAIL; mRemoteViews.setTextViewText(R.id.bt, "重试"); mRemoteViews.setTextViewText(R.id.tv_message, "下载失败"); notificationManager.notify(NOTIFICATION_ID, notification); EventBus.getDefault().post(new AppUpdateEvent(AppUpdateEvent.Type.ERROR)); //stopSelf(); } /** * 下载成功 */ private void downloadSuccess() { status = Status.SUCCESS; mRemoteViews.setTextViewText(R.id.bt, "完成"); mRemoteViews.setTextViewText(R.id.tv_message, "下载完成"); notificationManager.notify(NOTIFICATION_ID, notification); EventBus.getDefault().post(new AppUpdateEvent(AppUpdateEvent.Type.SUCCESS)); } /** * 销毁时取消下载，并取消注册广播，防止内存溢出 */ @Override public void onDestroy() { if (myBroadcastReceiver != null) { unregisterReceiver(myBroadcastReceiver); } super.onDestroy(); }}]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式-工厂方法模式详解]]></title>
    <url>%2F20190806%2F23-design-patterns-detailed-explanation-of-the-factory-method-mode.html</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式-单例模式详解]]></title>
    <url>%2F20190806%2F23-design-patterns-single-case-mode.html</url>
    <content type="text"><![CDATA[单例模式详解单例模式的定义与特点 单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。(计算机系统中,很多功能都被设计成单例) 单例模式有 3 个特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点；单例模式的结构与实现 结构 单例类：包含一个实例且能自行创建这个实例的类。 访问类：使用单例的类。 实现 懒汉式单例 //注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。 //该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下： public class LazySingleton{ private static volatile LazySingleton instance=null; //保证 instance 在所有线程中同步 private LazySingleton(){} //private 避免类在外部被实例化 public static synchronized LazySingleton getInstance() { //getInstance 方法前加同步 if(instance==null) { instance=new LazySingleton(); } return instance; }} 饿汉式单例 //该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了 public class HungrySingleton{ private static final HungrySingleton instance=new HungrySingleton(); private HungrySingleton(){} public static HungrySingleton getInstance() { return instance; }}]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式:23种设计模式]]></title>
    <url>%2F20190806%2Fjava-design-pattern-23-patterns.html</url>
    <content type="text"><![CDATA[前言什么是设计模式？ 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性.来源 分类三大分类 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。 结构型模式：把类或对象结合在一起形成一个更大的结构。 行为型模式：类和对象如何交互，及划分责任和算法。 细述23种设计模式 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Handler时如何有效地避免内存泄漏问题？]]></title>
    <url>%2F20190802%2Fhow-to-effectively-avoid-memory-leaks-when-customizing-handlers.html</url>
    <content type="text"><![CDATA[前言为什么要用自定义Handler？ android以下是网站接入https教程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Daily question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客加入https支持]]></title>
    <url>%2F20190801%2Fhexo-blog-to-join-https-support.html</url>
    <content type="text"><![CDATA[前言浏览器左上角会显示一把锁，这个就叫做https,有人说Google早在2014年8月对外宣称它会影响网站的SEO排名，并在2018年2月发布了另外一个声明，如果网站没有开通https，2018年7月以后浏览器会强制显示该网站不安全。现在都2019年了~，其实https这一块Google也在弱化显示这一块，没办法现在建站门槛太低，很多人网站建好之后就不维护了，更别说https的加入了.我这次加入https 也是因为在加入评论功能的时候左上角显示个警告图标（没办法！强迫症晚期）.以下是网站接入https教程 流程 先通过此链接检查你的网站是否打开了443端口(github page可跳过) 申请ssl证书(在你域名解析商那申请，建议使用cloudflare) 阿里云免费SSL证书，保护类型选择1个域名，选择品牌选择Symantec，即可看到免费型DV SSL。 腾讯云免费SSL证书 七牛免费SSL证书 cloudflare 上传ssl证书 并配置cloudflare 不管你的网站是搭建在github page 还是vps ，以下方法都适用cloudflare 官网 手动配置流程 阿里云、腾讯云和七牛，注册登录，根据提示填写信息，不久就可以拿到证书。 解压www.simcom.ltd.zip，可以得到下列文件： www.simcom.ltd │ www.simcom.ltd.csr │ ├─Apache │ 1_root_bundle.crt │ 2_www.simcom.ltd.crt │ 3_www.simcom.ltd.key │ ├─IIS │ keystorePass.txt │ www.simcom.ltd.pfx │ ├─Nginx │ 1_www.simcom.ltd_bundle.crt │ 2_www.simcom.ltd.key │ └─Tomcat keystorePass.txt www.simcom.ltd.jks 上传证书 服务器上，创建目录sslmkdir /etc/nginx/ssl 将Nginx文件夹中的文件使用xftp上传到ssl目录(我这边是nginx环境) 配置nginx /etc/nginx/conf.d中新建配置文件www.simcom.ltd.conf server { listen 80; listen 443 ssl; server_name www.simcom.ltd; charset utf-8; #ssl配置 ssl_certificate /etc/nginx/ssl/1_www.simcom.ltd_bundle.crt; ssl_certificate_key /etc/nginx/ssl/2_www.simcom.ltd.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 1024m; client_body_buffer_size 128k; client_body_temp_path /var/data/client_body_temp; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_temp_path /var/data/proxy_temp; } } 重启nginxsystemctl restart nginx 参考www.voidking.com]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo链接SEO优化]]></title>
    <url>%2F20190731%2Fhexo-link-seo-optimization.html</url>
    <content type="text"><![CDATA[前言hexo 生成文章的默认链接是“https://blog.simcom.ltd/2019/01/14/“Markdown file name””,如果文章标题是英文的还好，如果是中文的，看着就各种别扭，而且这样也不利于seo优化。以下内容是讲如何做链接的seo优化. 优化方法 添加urlname属性(手动) hexo插件法(hexo插件官网) hexo-translate-title: Translate the chinese title of Hexo blog to english words automatially hexo-permalink-pinyin: A Hexo plugin which convert Chinese title to transliterate permalink. hexo-abbrlink: Auto create one and only link for every post for hexo hexo-number-title: The hexo blog post url is displayed as a number. 添加urlname属性在md文件的Front-matter区域新增urlname属性，可以是文章的英文Title也可以是其它自定义标识，所以每次编写Markdown你都得这么做，参考如下 --- title: hexo链接SEO优化 urlname: Hexo link SEO optimization date: 2019-1-14 categories: hexo author: mendax tags: hexo cover_picture: http://xxx.xx/xxx.jpg top: 1 --- 利用hexo插件大概看了下，这些插件其实主要还是两个方法的是实现地址的唯一性 生成唯一的值当作链接的地址 通过翻译的方式生成英文的地址 我这里选择的是hexo-translate-title 安装npm install hexo-translate-title --save 配置修改hexo根项目下的_config.yml translate_title: translate_way: google # google,youdao,baidu_with_appid,baidu_no_appid is_need_proxy: false # true | false # proxy_url: http://localhost:50018 # Your proxy_url # youdao_api_key: '' # Your youdao_api_key # youdao_keyfrom: xxxx-blog # Your youdao_keyfrom # baidu_appid: '' # Your baidu_appid # baidu_appkey: '' # Your baidu_appkey #修改原链接格式：permalink: :year/:month/:day/:title/ permalink: :year:month:day/:translate_title.html 发布hexo clean hexo g gulp // 执行压缩，两条命令可以合并：hexo g && gulp hexo d //执行部署命令]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gulp4对Hexo博客压缩]]></title>
    <url>%2F20190731%2Fcompress-hexo-blog-with-gulp4.html</url>
    <content type="text"><![CDATA[安装插件在博客的根目录执行以下命令 npm install gulp --save 安装功能模块介绍(我压缩图片用不上，我的图片全部上传github) gulp-htmlclean // 清理html gulp-htmlmin // 压缩html gulp-minify-css // 压缩css gulp-uglify // 混淆js gulp-imagemin // 压缩图片npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save gulp配置在根目录下创建gulpfile.js文件var gulp = require('gulp'); //Plugins模块获取 var minifycss = require('gulp-minify-css'); var uglify = require('gulp-uglify'); var htmlmin = require('gulp-htmlmin'); var htmlclean = require('gulp-htmlclean'); //压缩css gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public')); }); //压缩html gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public')) }); //压缩js 不压缩min.js gulp.task('minify-js', function () { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']) .pipe(uglify()) .pipe(gulp.dest('./public')); }); //4.0以前的写法 //gulp.task('default', [ // 'minify-html', 'minify-css', 'minify-js' //]); //4.0以后的写法 // 执行 gulp 命令时执行的任务 gulp.task('build', gulp.parallel('minify-html', 'minify-css', 'minify-js', function() { // Do something after a, b, and c are finished. })); 执行压缩hexo clean hexo g gulp // 执行压缩，两条命令可以合并：hexo g && gulp hexo d //执行部署命令]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo增加搜索功能]]></title>
    <url>%2F20190731%2Fhexo-increases-search-function.html</url>
    <content type="text"><![CDATA[安装插件在博客的根目录执行以下命令 npm install hexo-generator-searchdb --save 全局配置文件_config.ymlsearch: path: search.xml field: post format: html limit: 10000 hexo主题配置文件# Local search # Dependencies: https://github.com/flashlab/hexo-generator-search local_search: enable: true]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用Hexo脚本——备份博客源文件]]></title>
    <url>%2F20190731%2Fuse-hexo-scripts-backup-blog-source-files.html</url>
    <content type="text"><![CDATA[Hexo脚本 Hexo命令会自动触发一些事件，利用这些事件，我们可以为不同的Hexo命令添加一些额外的自定义功能。我们只需要在Hexo根目录下添加一个scripts文件夹，然后将我们编写的脚本文件放在这个文件夹中，当某一事件被触发时，接收相应事件的脚本就会被自动执行。 自动备份博客源文件 Hexo部署的github-pages博客在发布时只会上传生成的页面文件，而我们的源文件却没有上传,这就导致博客源文件没有备份，当然我们可以在GitHub上新建一个repo来管理我们的源文件，但是这样每次都需要手动备份，有点麻烦。这个时候，就需要利用Hexo事件来运行自动脚本了。直接上代码： // filename: backup.js require('shelljs/global'); try { hexo.on('generateAfter', function() {//当generate完成后执行备份 run(); }); } catch (e) { console.log("产生了一个错误 !，错误详情为：" + e.toString()); } function run() { echo("==================Source Auto Backup Begin========================"); cd('/home/dhmemi/Documents/blog_dhmemi'); //此处修改为Hexo根目录路径 exec('if [ ! -d "public" ]; then\nmkdir public\nfi'); if (exec('cp -avx source public/').code !== 0) { echo('Error: copy source failed'); exit(1); } else { echo("==============Source Auto Backup Complete=========================") } } 这个脚本所完成的功能很简单，就是在Hexo生成（generate）完成后，将source文件夹复制到public目录下，这样，在发布（deploy）时，源文件目录就会自动被复制到.git_deploy目录下并被当作生成目录发布到github上。保存上面的脚本到scripts目录下即可。当然在运行这个脚本之前，你一定注意到了第一行的”shelljs/global”，所以你要安装shelljs模块： sudo npm install --save shelljs]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动过程中获取组件宽高的五种方式]]></title>
    <url>%2F20190730%2Ffive-ways-to-get-the-width-and-height-of-components-during-startup-process.html</url>
    <content type="text"><![CDATA[问题：在Activity的启动流程中通过getWidht和getHeight方法获取组件的宽度和高度//在onCreate方法中调用，用于获取TextView的宽度和高度 private void getTextHeightAndWidth() { // 我们定义的用于获取宽度和高度的组件 titleText = (TextView) findViewById(R.id.text_title); int height = titleText.getHeight(); int width = titleText.getWidth(); Log.i(TAG, "height:" + height + " " + "width:" + width); } 打印结果I/MainActivity: height:0 width:0 咦？为什么打印的height和width都是0呢？我们在执行一遍呢？结果还是一样的，两个变量都是0，难道这段代码不能再onCreate方法中调用，那么我们试试在onResume方法中调用呢？ 只能说然并卵，打印的结果依然是： I/MainActivity: height:0 width:0 好吧，问题已经出来了，看样子我们是不能再onCreate方法或者是onResume方法中调用该方法获取组件的宽高的，但是这是为什么呢？平时我们都是通过这个方法来获取组件的宽高的，并且也没问题啊，比如我们将这个方法的调用逻辑写在按钮的点击事件之内呢？我们再来试试。 //这里的button1是我们定义的Button组件，并且我们重写了Button的点击事件，在其中调用了获取组件宽高的方法 button1 = (Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getTextHeightAndWidth(); } }); 这样敲完代码之后，我们执行这段代码，界面入下图所示： 打印结果I/MainActivity: height:57 width:225 恩？这时候我们发现其打印出了组件的宽和高，那么为什么我们在Activity的onCreate、onResume方法中打印的时候，输出的组件宽高都是为0呢？ 原因 Activity的启动流程和Activity的布局文件加载绘制流程，其实没有相关的关系的，其实两个异步的加载流程，这样我们在Activity的onCreate和onResume方法调用textView.getHeight或者是textView.getWidth方法的时候，其组件并没有执行完绘制流程，因此此时获取到的组件的宽高都是默认的0，也就是无法获取组件的宽和高。但是当我们将获取组件宽高的方法卸载按钮的点击事件的时候，由于此时按钮已经显示出来了，所以证明布局文件已经加载绘制完成，这时候点击组件执行组件的获取宽高方法，就能正常的获取到组件的宽和高了。这也就是为什么我们在onCreate和onResume方法中调用获取组件宽高都是0，而在按钮的点击事件中获取的时候正常的原因了 解决方案重写Activity的onWindowFocusChanged方法//重写Acitivty的onWindowFocusChanged方法 @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); /** * 当hasFocus为true的时候，说明Activity的Window对象已经获取焦点，进而Activity界面已经加载绘制完成 */ if (hasFocus) { int widht = titleText.getWidth(); int height = titleText.getHeight(); Log.i(TAG, "onWindowFocusChanged width:" + widht + " " + " height:" + height; } } 说明：这样重写onWindowFocusChanged方法，当获取焦点的时候我们就可以通过getWidth和getHeight方法得到组件的宽和高了。但是这时候这个方法的逻辑可能会执行多次，也就是说只要我们的Activity的window对象获取了焦点就会执行该语句，所以我们需要做一些逻辑判断，让它在我们需要打印获取组件宽高的时候在执行。 为组件添加OnGlobalLayoutListener事件监听/** * 为Activity的布局文件添加OnGlobalLayoutListener事件监听，当回调到onGlobalLayout方法的时候我们通过getMeasureHeight和getMeasuredWidth方法可以获取到组件的宽和高 */ private void initOnLayoutListener() { final ViewTreeObserver viewTreeObserver = this.getWindow().getDecorView().getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { Log.i(TAG, "开始执行onGlobalLayout()........."); int height = titleText.getMeasuredHeight(); int width = titleText.getMeasuredWidth(); Log.i(TAG, "height:" + height + " width:" + width); // 移除GlobalLayoutListener监听 MainActivity.this.getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(this); } }); } 说明需要说明的是这里的onGlobalLayout方法会在Activity的组件执行完onLayout方法之后执行，这里的onLayout方法主要用于计算组件的宽高操作，具体可参考：Android源码解析（十八）–&gt;Activity布局绘制流程，这样当我们计算完组件的宽高之后再执行获取组件的宽高操作，自然能够获取到组件的宽度和高度。 为组件添加OnPreDrawListener事件监听/** * 初始化viewTreeObserver事件监听,重写OnPreDrawListener获取组件高度 */ private void initOnPreDrawListener() { final ViewTreeObserver viewTreeObserver = this.getWindow().getDecorView().getViewTreeObserver(); viewTreeObserver.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { Log.i(TAG, "开始执行onPreDraw()........."); int height = titleText.getMeasuredHeight(); int width = titleText.getMeasuredWidth(); Log.i(TAG, "height:" + height + " width:" + width); // 移除OnPreDrawListener事件监听 MainActivity.this.getWindow().getDecorView().getViewTreeObserver().removeOnPreDrawListener(this); return true; } }); } 说明需要说明的是这里的onPreDraw方法会在Activity的组件执行onDraw方法之前执行，熟悉我们Activity组件加载绘制流程的同学应该知道，这里的onDraw方法主要用于执行真正的绘制组件操作，而这时候我们已经计算出来了组件的位置，宽高等操作，这样之后再执行获取组件的宽高操作，自然能够获取到组件的宽度和高度。 使用View.post方法获取组件的宽高/** * 使用View的post方法获取组件的宽度和高度 */ private void initViewHandler() { titleText.post(new Runnable() { @Override public void run() { int width = titleText.getWidth(); int height = titleText.getHeight(); Log.i(TAG, "initViewHandler height:" + height + " width:" + width); } }); } 说明这里的view的post方法底层使用的是Android的异步消息机制，消息的执行在MainActivity主进程Loop执行之后，所以这时候也可以获取组件的宽高 通过Handler对象使用异步消息获取组件的宽高/** * 在onCreate方法中发送异步消息，在handleMessage中获取组件的宽高 */ private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { int width = titleText.getWidth(); int height = titleText.getHeight(); Log.i(TAG, "initViewHandler height:" + height + " width:" + width); } } }; 说明和上面使用view.post方法类似，这里用的是异步消息获取组件的宽高，而这里的异步消息的执行过程是在主进程的主线程的Activity绘制流程之后，所以这时候可以获取组件的宽高]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的搭建]]></title>
    <url>%2F20190726%2Fhexo-blog-building.html</url>
    <content type="text"><![CDATA[准备工作(window7 64位) 下载node.js并安装（node官网下载安装），默认会安装npm 下载安装git（git官网下载安装） 下载安装hexo(hexo官方文档) 安装Node控制台打印出对应Node版本就说明安装成功了 node -v 安装git 校验是否安装成功 git version 安装hexo 下载 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 全局安装 npm install -g hexo #-g 全局安装hexo 校验是否安装成功 hexo -v 生成hexo模板进入相对应的目录（我这边是D磁盘下） hexo init blog #blog 我这边是直接在D盘下 创建个blog 文件夹 cd blog npm install hexo server #运行程序，访问本地localhost:4000可以看到博客已经搭建成功 将博客与Github关联 在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名(一个账号只能创建一个githubpage，且后缀必须“.github.io”) 打开本地的Blog文件夹项目内的_config.yml配置文件，将其中的type设置为git，其中repository 可为SSH地址(我这是SSH地址) deploy: type: git repository: git@github.com:mendax92/mendax92.github.io.git branch: master 或者 deploy: type: git repository: https://github.com/mendax92/mendax92.github.io.git branch: master 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题) cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。``` ssh-keygen -t rsa -C "邮件地址" #找到.ssh\id_rsa.pub文件，打开并复制里面的内容，->github主页，->个人设置 -> SSH and GPG keys -> New SSH key ssh -T git@github.com #测试是否成功 git config --global user.name "liuxianan"// 你的github用户名，非昵称 git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 安装hexo-deployer-git插件包并发布 npm install hexo-deployer-git –save hexo g #（本地生成静态文件） hexo d #（将本地静态文件推送至Github） 更新文章定位到我们的hexo根目录，执行命令 Hexo官网指令大全 hexo new 'my-first-blog' #hexo会帮我们在_posts下生成相关md文件|也可以手动在_posts创建文件 hexo clean #清除缓存文件 hexo g #生成静态页面至public目录 hexo s #启动服务器 hexo d #部署网站 添加页面hexo new page "categories" #添加分类页面 hexo new page “tags” #添加标签页面 hexo new page "about #添加关于页面]]></content>
      <categories>
        <category>博客的搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnsupportedOperationException错误分析]]></title>
    <url>%2F20190726%2Funsupportedoperationexception-error-analysis.html</url>
    <content type="text"><![CDATA[1. 错误分析 java.lang.UnsupportedOperationException 大致的意思是，你调用的关于的容器的操作是不被允许的。 2. 个人理解 这不是说没有该方法，如果没有该方法的话，在编译期间就可以识别。 有该方法，也就是说该方法受到了限制。 限制就类似于权限限制之类的东西。（类似于linux 中对于文件权限的管理）。如果list不能实现这种权限的限制，那么会存在一些安全性的问题。所以可以看出来，权限在大部分场合都是一个必备的成分。 不同的粒度上，相关的语言提供了不同控制权限的方式。 本质上，下面的错误案例，都可以归结为权限问题。 3. 举例Collections.unmodifiableList（*）引起的错误Collections.unmodifiableList 起到了对list**设置权限的目的**。 private static void testReadOnly(){ //1.创建一个list。并且这个list的访问权限未进行设置。 List modifyList = new ArrayList(); //2.向其中插入相关的数据。【可行】 modifyList.add("you"); modifyList.add("are"); modifyList.add("boy"); //3.对list进行设置。使之可读。 modifyList = Collections.unmodifiableList(modifyList); //4.在次插入，出现错误。 modifyList.add("hello"); } 解决办法 该只读的权限维护的是，修改list中引用的权限。 但是如果你如果不改引用，是可以通过引用来更改其所指向的对象的。 private static void testChangeReadOnly(){ ////1.创建2个list。并且这2个list的访问权限未进行设置。 List modifyList = new ArrayList(); List normalList= new LinkedList(); //2.向modifylist中插入元素。 modifyList.add(new StringBuilder("you")); modifyList.add(new StringBuilder("are")); modifyList.add(new StringBuilder("boy")); //3.设置可读权限 modifyList = Collections.unmodifiableList(modifyList); //4.将只读的modifyList中的引用复制到normalList中。 normalList.addAll(modifyList); //5.向normalList中插入数据。 normalList.add(new StringBuilder("hello")); System.out.println(normalList.toString());//[you, are, boy, hello] //6.更改只读list中，引用所指向的对象的值。 System.out.println("更改之前 ----> " + modifyList.toString());//更改之前 ----> [you, are, boy] //更改 modifyList.get(1).append("~~~~~"); System.out.println("更改之后 ----> " + modifyList.toString());//更改之后 ----> [you, are~~~~~, boy] } 输出结果： [you, are, boy, hello]更改之前 —-&gt; [you, are, boy]更改之后 —-&gt; [you, are~, boy] 使用Arrays.asLisvt()后调用add，remove这些method时出现 Arrays.asLisvt() 返回java.util.ArraysArrayList，而不是ArrayList。 ArraysArrayList和ArrayList都是继承AbstractList，remove，add等method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。 ArrayList override这些method来对list进行操作，但是Arrays$ArrayList没有override remove(int)，add(int)等，所以throw UnsupportedOperationException 解决办法和上面异常的处理一样，将引用操作转移到其他地方。 List list = Arrays.asList(fixArray[]); List newList = new ArrayList(list);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>错误分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断当前activity 是否在栈顶]]></title>
    <url>%2F20190726%2Fdetermine-if-the-current-activity-is-at-top-of-stack.html</url>
    <content type="text"><![CDATA[判断当前activity 是否在栈顶的两种方法 通过代码private static final String ACTIVITY_NAME_PARENTMEETING = "com.sunnyberry.xst.activity.parentmeeting.ParentMeetingActivity"; Utils.activityIsBackground(mContext, ACTIVITY_NAME_PARENTMEETING); /** * 判断activity是否是在栈顶 */ public static boolean activityIsBackground(Context context, String clazzName) { ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); RunningTaskInfo info = manager.getRunningTasks(1).get(0); String shortClassName = info.topActivity.getShortClassName(); //类名 String className = info.topActivity.getClassName(); //完整类名 String packageName = info.topActivity.getPackageName(); //包名 if (TextUtils.isEmpty(clazzName)) { return false; } return (clazzName.equals(className)); } 通过adb命令行获取当前的activityadb shell dumpsys activity | findstr “mFocusedActivity”]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
